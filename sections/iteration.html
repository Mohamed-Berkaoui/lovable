<!DOCTYPE html>
<html lang="en" data-lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Iteration &amp; Refinement – Lovable Course</title>
  <link rel="stylesheet" href="../css/style.css" />
</head>
<body>

  <!-- ====== Header ====== -->
  <header class="section-header">
    <div class="container">
      <nav class="breadcrumb lang-en">
        <a href="../index.html">Home</a> <span>&rsaquo;</span> Iteration &amp; Refinement
      </nav>
      <nav class="breadcrumb lang-fr">
        <a href="../index.html">Accueil</a> <span>&rsaquo;</span> Itération &amp; Perfectionnement
      </nav>

      <h1 class="section-title lang-en">Iteration &amp; Refinement</h1>
      <h1 class="section-title lang-fr">Itération &amp; Perfectionnement</h1>

      <p class="section-subtitle lang-en">
        Software is never right on the first try. Master the feedback loop to build polished products.
      </p>
      <p class="section-subtitle lang-fr">
        Un logiciel n'est jamais parfait du premier coup. Maîtrisez la boucle de rétroaction pour créer des produits aboutis.
      </p>

      <span class="reading-time lang-en">&#128337; Estimated reading time: 11 minutes</span>
      <span class="reading-time lang-fr">&#128337; Temps de lecture estimé : 11 minutes</span>
    </div>
  </header>

  <!-- ====== Body ====== -->
  <main class="section-body">
    <div class="container">

      <!-- Iterative Workflow -->
      <h2 class="lang-en">The Iterative Workflow</h2>
      <h2 class="lang-fr">Le flux de travail itératif</h2>

      <div class="content-card">
        <p class="lang-en">
          Building with Lovable is not a one-shot process. The best results come from an
          <strong>iterative workflow</strong>: build something, review it, identify issues, refine
          it, and repeat.
        </p>
        <p class="lang-fr">
          Construire avec Lovable n'est pas un processus en une seule étape. Les meilleurs résultats proviennent d'un
          <strong>flux de travail itératif</strong> : construire quelque chose, l'examiner, identifier les problèmes, l'affiner
          et recommencer.
        </p>

        <p class="lang-en">
          This cycle is faster with Lovable than traditional development — often minutes per
          iteration instead of hours — but the principle is the same. Each pass makes the product
          better.
        </p>
        <p class="lang-fr">
          Ce cycle est plus rapide avec Lovable qu'avec le développement traditionnel — souvent quelques minutes par
          itération au lieu de plusieurs heures — mais le principe reste le même. Chaque passe améliore le produit.
        </p>

        <h3 class="lang-en">The Iteration Cycle</h3>
        <h3 class="lang-fr">Le cycle d'itération</h3>

        <ol class="steps-list lang-en">
          <li><strong>Prompt:</strong> Send a clear, focused prompt to Lovable.</li>
          <li><strong>Review:</strong> Examine the generated output in the preview.</li>
          <li><strong>Identify:</strong> Note what's correct, what's wrong, and what's missing.</li>
          <li><strong>Refine:</strong> Send a follow-up prompt that addresses only the issues.</li>
          <li><strong>Repeat:</strong> Continue until the feature meets your standards.</li>
        </ol>
        <ol class="steps-list lang-fr">
          <li><strong>Prompt :</strong> Envoyez un prompt clair et ciblé à Lovable.</li>
          <li><strong>Examen :</strong> Examinez le résultat généré dans l'aperçu.</li>
          <li><strong>Identification :</strong> Notez ce qui est correct, ce qui ne l'est pas et ce qui manque.</li>
          <li><strong>Affinage :</strong> Envoyez un prompt de suivi qui traite uniquement les problèmes.</li>
          <li><strong>Répétition :</strong> Continuez jusqu'à ce que la fonctionnalité atteigne vos standards.</li>
        </ol>
      </div>

      <div class="highlight-box info lang-en">
        <p class="box-title">&#128218; Why It Works</p>
        <p>
          Iteration works because each refinement prompt has more context (the AI can see what it
          already built). The AI gets smarter about your project with every exchange.
        </p>
      </div>
      <div class="highlight-box info lang-fr">
        <p class="box-title">&#128218; Pourquoi ça fonctionne</p>
        <p>
          L'itération fonctionne parce que chaque prompt d'affinage dispose de plus de contexte (l'IA peut voir ce qu'elle
          a déjà construit). L'IA comprend mieux votre projet à chaque échange.
        </p>
      </div>

      <!-- Feedback Loops -->
      <h2 class="lang-en">Feedback Loops</h2>
      <h2 class="lang-fr">Boucles de rétroaction</h2>

      <div class="content-card">
        <p class="lang-en">
          A <strong>feedback loop</strong> is the process of observing output, forming a response,
          and feeding that response back into the system. In Lovable, there are three types:
        </p>
        <p class="lang-fr">
          Une <strong>boucle de rétroaction</strong> est le processus d'observation du résultat, de formulation d'une réponse
          et de réinjection de cette réponse dans le système. Dans Lovable, il en existe trois types :
        </p>

        <h3 class="lang-en">1. Visual Feedback</h3>
        <h3 class="lang-fr">1. Rétroaction visuelle</h3>

        <p class="lang-en">
          Look at the preview. Does the layout match your expectation? Are colours correct? Is
          spacing consistent? Are elements aligned?
        </p>
        <p class="lang-fr">
          Regardez l'aperçu. La mise en page correspond-elle à vos attentes ? Les couleurs sont-elles correctes ?
          L'espacement est-il cohérent ? Les éléments sont-ils alignés ?
        </p>

        <h3 class="lang-en">2. Functional Feedback</h3>
        <h3 class="lang-fr">2. Rétroaction fonctionnelle</h3>

        <p class="lang-en">
          Click through the app. Do buttons work? Do forms validate? Does navigation route
          correctly? Do loading states appear?
        </p>
        <p class="lang-fr">
          Naviguez dans l'application. Les boutons fonctionnent-ils ? Les formulaires sont-ils validés ? La navigation
          fonctionne-t-elle correctement ? Les états de chargement s'affichent-ils ?
        </p>

        <h3 class="lang-en">3. Data Feedback</h3>
        <h3 class="lang-fr">3. Rétroaction des données</h3>

        <p class="lang-en">
          Does the app fetch and display real data? Are database operations (create, read, update,
          delete) working? Are error states handled for empty or failed queries?
        </p>
        <p class="lang-fr">
          L'application récupère-t-elle et affiche-t-elle des données réelles ? Les opérations de base de données (création, lecture, mise à jour,
          suppression) fonctionnent-elles ? Les états d'erreur sont-ils gérés pour les requêtes vides ou échouées ?
        </p>

        <div class="highlight-box tip lang-en">
          <p class="box-title">&#128161; Tip</p>
          <p>
            Test on mobile view after every major change. Many issues (overflow, tiny text, broken
            grids) only appear on smaller screens. Lovable's preview has a mobile toggle — use it.
          </p>
        </div>
        <div class="highlight-box tip lang-fr">
          <p class="box-title">&#128161; Conseil</p>
          <p>
            Testez en vue mobile après chaque changement majeur. De nombreux problèmes (débordement, texte trop petit, grilles cassées)
            n'apparaissent que sur les petits écrans. L'aperçu de Lovable dispose d'un basculement mobile — utilisez-le.
          </p>
        </div>
      </div>

      <!-- Refinement Strategies -->
      <h2 class="lang-en">Refinement Strategies</h2>
      <h2 class="lang-fr">Stratégies d'affinage</h2>

      <div class="content-card">
        <h3 class="lang-en">Strategy 1: Surgical Prompts</h3>
        <h3 class="lang-fr">Stratégie 1 : Prompts chirurgicaux</h3>

        <p class="lang-en">
          Instead of re-describing the entire feature, target the specific problem:
        </p>
        <p class="lang-fr">
          Au lieu de re-décrire la fonctionnalité entière, ciblez le problème spécifique :
        </p>

        <div class="code-block">
          <span class="code-label lang-en">Example</span>
          <span class="code-label lang-fr">Exemple</span>
          <code>❌ Bad: "Rebuild the product card to look better."

✅ Good: "On the product card component:
1. Increase image height from 200px to 280px
2. Add 8px border radius to the image
3. Change price colour to #16a34a (green)
4. Add a subtle hover shadow (shadow-lg on hover)"</code>
        </div>

        <h3 class="lang-en">Strategy 2: Reference the Existing Output</h3>
        <h3 class="lang-fr">Stratégie 2 : Référencer le résultat existant</h3>

        <p class="lang-en">
          Tell the AI what's already correct so it doesn't break working parts:
        </p>
        <p class="lang-fr">
          Indiquez à l'IA ce qui est déjà correct pour qu'elle ne casse pas les éléments fonctionnels :
        </p>

        <div class="code-block">
          <span class="code-label lang-en">Example</span>
          <span class="code-label lang-fr">Exemple</span>
          <code>"The product list page layout is correct.
Do NOT change the grid or card structure.
Only add a 'Sort by Price' dropdown above the grid
that sorts products ascending/descending."</code>
        </div>

        <h3 class="lang-en">Strategy 3: Fix One Thing at a Time</h3>
        <h3 class="lang-fr">Stratégie 3 : Corriger une chose à la fois</h3>

        <p class="lang-en">
          If you found 5 issues, send 5 focused prompts — not one massive one. This gives the AI
          clear context for each fix and reduces the chance of introducing new bugs.
        </p>
        <p class="lang-fr">
          Si vous avez trouvé 5 problèmes, envoyez 5 prompts ciblés — pas un seul massif. Cela donne à l'IA
          un contexte clair pour chaque correction et réduit le risque d'introduire de nouveaux bugs.
        </p>

        <h3 class="lang-en">Strategy 4: Use "Keep / Change / Remove" Format</h3>
        <h3 class="lang-fr">Stratégie 4 : Utiliser le format « Keep / Change / Remove »</h3>

        <div class="code-block">
          <span class="code-label lang-en">Example</span>
          <span class="code-label lang-fr">Exemple</span>
          <code>On the checkout page:

KEEP:
- The form layout (shipping address fields)
- The order summary sidebar

CHANGE:
- Submit button colour from grey to purple (#7c3aed)
- Add form validation messages below each field

REMOVE:
- The "Apply Coupon" section (not needed for MVP)</code>
        </div>
      </div>

      <!-- Example: Improving UI -->
      <h2 class="lang-en">Example: Improving UI</h2>
      <h2 class="lang-fr">Exemple : Améliorer l'interface utilisateur</h2>

      <div class="content-card">
        <h3 class="lang-en">Initial Output (after first prompt)</h3>
        <h3 class="lang-fr">Résultat initial (après le premier prompt)</h3>

        <p class="lang-en">
          The AI generated a product list page. The layout works, but the cards look flat, spacing
          is too tight, and there's no hover effect.
        </p>
        <p class="lang-fr">
          L'IA a généré une page de liste de produits. La mise en page fonctionne, mais les cartes semblent plates, l'espacement
          est trop serré et il n'y a pas d'effet au survol.
        </p>

        <h3 class="lang-en">Refinement Prompt</h3>
        <h3 class="lang-fr">Prompt d'affinage</h3>

        <div class="code-block">
          <span class="code-label lang-en">Prompt</span>
          <span class="code-label lang-fr">Prompt</span>
          <code>"Improve the product list page visuals:
1. Add shadow-md to each product card
2. Add 16px gap between cards (currently too tight)
3. On hover: scale card to 1.02 and increase shadow to shadow-lg
4. Add a subtle border (1px solid #e2e8f0) to each card
5. Round card corners to 12px
6. Add a fade-in animation when cards load (300ms ease)"</code>
        </div>

        <p class="lang-en">Result: The AI updates only the visual properties without breaking layout or data.</p>
        <p class="lang-fr">Résultat : l'IA met à jour uniquement les propriétés visuelles sans casser la mise en page ni les données.</p>
      </div>

      <!-- Example: Fixing Logic -->
      <h2 class="lang-en">Example: Fixing Logic</h2>
      <h2 class="lang-fr">Exemple : Corriger la logique</h2>

      <div class="content-card">
        <h3 class="lang-en">Bug Found</h3>
        <h3 class="lang-fr">Bug trouvé</h3>

        <p class="lang-en">
          The cart allows adding the same item multiple times as separate entries instead of
          incrementing the quantity.
        </p>
        <p class="lang-fr">
          Le panier permet d'ajouter le même article plusieurs fois sous forme d'entrées séparées au lieu
          d'incrémenter la quantité.
        </p>

        <h3 class="lang-en">Fix Prompt</h3>
        <h3 class="lang-fr">Prompt de correction</h3>

        <div class="code-block">
          <span class="code-label lang-en">Prompt</span>
          <span class="code-label lang-fr">Prompt</span>
          <code>"Fix the cart logic:
When a user adds a product that is already in the cart,
do NOT add a new entry. Instead, find the existing entry
by product ID and increment its quantity by 1.
Show a toast notification: 'Quantity updated' instead
of 'Added to cart' when incrementing."</code>
        </div>
      </div>

      <!-- Example: Enhancing UX -->
      <h2 class="lang-en">Example: Enhancing UX</h2>
      <h2 class="lang-fr">Exemple : Améliorer l'expérience utilisateur</h2>

      <div class="content-card">
        <h3 class="lang-en">Issue</h3>
        <h3 class="lang-fr">Problème</h3>

        <p class="lang-en">
          The app works but feels static. There's no feedback when actions happen, and loading
          states are missing.
        </p>
        <p class="lang-fr">
          L'application fonctionne mais semble statique. Il n'y a aucun retour lorsque des actions se produisent, et les
          états de chargement sont absents.
        </p>

        <h3 class="lang-en">Enhancement Prompt</h3>
        <h3 class="lang-fr">Prompt d'amélioration</h3>

        <div class="code-block">
          <span class="code-label lang-en">Prompt</span>
          <span class="code-label lang-fr">Prompt</span>
          <code>"Enhance UX across the app:
1. Add skeleton loaders to all pages that fetch data
   (replace the empty white screen while loading)
2. Add toast notifications for all user actions:
   - 'Added to cart' (success, green)
   - 'Removed from cart' (info, blue)
   - 'Order placed!' (success, green)
   - 'Error: please try again' (error, red)
3. Add loading spinner inside submit buttons while
   async operations are in progress
4. Disable submit buttons during loading to prevent
   double-clicks"</code>
        </div>
      </div>

      <div class="highlight-box warning lang-en">
        <p class="box-title">&#9888;&#65039; Common Pitfall</p>
        <p>
          Don't iterate endlessly on small visual tweaks. Set a "good enough" bar for your MVP.
          You can always polish later. The goal of iteration is finding and fixing <em>real
          problems</em>, not achieving pixel-perfection on day one.
        </p>
      </div>
      <div class="highlight-box warning lang-fr">
        <p class="box-title">&#9888;&#65039; Piège courant</p>
        <p>
          N'itérez pas indéfiniment sur de petits ajustements visuels. Établissez un seuil « suffisamment bon » pour votre MVP.
          Vous pourrez toujours peaufiner plus tard. L'objectif de l'itération est de trouver et corriger les <em>vrais
          problèmes</em>, pas d'atteindre la perfection au pixel près dès le premier jour.
        </p>
      </div>

      <!-- Summary -->
      <h2 class="lang-en">Section Summary</h2>
      <h2 class="lang-fr">Résumé de la section</h2>

      <div class="content-card">
        <ol class="steps-list lang-en">
          <li>Use the iterate cycle: Prompt → Review → Identify → Refine → Repeat.</li>
          <li>Three feedback types: visual (how it looks), functional (how it works), data (what it shows).</li>
          <li>Write surgical, specific refinement prompts — not vague rewrites.</li>
          <li>Fix one issue per prompt for best results.</li>
          <li>Use the Keep / Change / Remove format for complex refinements.</li>
          <li>Set a "good enough" bar for MVP — don't iterate forever.</li>
        </ol>
        <ol class="steps-list lang-fr">
          <li>Utilisez le cycle itératif : Prompt → Examen → Identification → Affinage → Répétition.</li>
          <li>Trois types de rétroaction : visuelle (apparence), fonctionnelle (comportement), données (contenu affiché).</li>
          <li>Rédigez des prompts d'affinage chirurgicaux et spécifiques — pas de reformulations vagues.</li>
          <li>Corrigez un seul problème par prompt pour de meilleurs résultats.</li>
          <li>Utilisez le format Keep / Change / Remove pour les affinages complexes.</li>
          <li>Établissez un seuil « suffisamment bon » pour le MVP — n'itérez pas indéfiniment.</li>
        </ol>
      </div>

    </div>
  </main>

  <!-- ====== Footer ====== -->
  <footer class="section-footer">
    <a href="../index.html" class="btn btn-back lang-en">&larr; Back to Presentation</a>
    <a href="../index.html" class="btn btn-back lang-fr">&larr; Retour à la présentation</a>
  </footer>

  <script src="../js/lang.js"></script>
</body>
</html>
